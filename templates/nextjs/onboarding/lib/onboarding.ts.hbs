import { prisma } from "@/lib/prisma";

export const ONBOARDING_STEPS = [
{{#each steps}}
  { id: "{{this}}", title: "{{this}}", order: {{@index}} },
{{/each}}
] as const;

export type OnboardingStepId = typeof ONBOARDING_STEPS[number]["id"];

export async function getOnboardingProgress(userId: string) {
  const progress = await prisma.onboardingProgress.findUnique({
    where: { userId },
  });

  return {
    completedSteps: (progress?.completedSteps as string[]) || [],
    currentStep: (progress?.currentStep as string) || ONBOARDING_STEPS[0].id,
    isComplete: progress?.completedAt !== null,
  };
}

export async function completeStep(userId: string, stepId: string) {
  const progress = await prisma.onboardingProgress.upsert({
    where: { userId },
    create: {
      userId,
      currentStep: stepId,
      completedSteps: [stepId],
    },
    update: {
      completedSteps: { push: stepId },
    },
  });

  // Check if all steps are complete
  const completedSteps = progress.completedSteps as string[];
  if (ONBOARDING_STEPS.every((s) => completedSteps.includes(s.id))) {
    await prisma.onboardingProgress.update({
      where: { userId },
      data: { completedAt: new Date() },
    });
  }

  // Advance current step
  const currentIndex = ONBOARDING_STEPS.findIndex((s) => s.id === stepId);
  const nextStep = ONBOARDING_STEPS[currentIndex + 1];
  if (nextStep) {
    await prisma.onboardingProgress.update({
      where: { userId },
      data: { currentStep: nextStep.id },
    });
  }

  return progress;
}

export async function skipOnboarding(userId: string) {
  return prisma.onboardingProgress.upsert({
    where: { userId },
    create: { userId, currentStep: "", completedSteps: [], completedAt: new Date() },
    update: { completedAt: new Date() },
  });
}
